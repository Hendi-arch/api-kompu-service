# Copilot Instructions for api-kompu-service

## Project Overview

**api-kompu-service** is a multi-tenant Spring Boot 4.0 microservice providing user account, role, and authentication management. The application uses **JWT tokens** for stateless authentication, PostgreSQL for data persistence, and is designed for deployment in containerized multi-tenant environments.

**Key technologies:** Java 21, Spring Security, Spring Data JPA, JWT (JJWT 0.13.0), PostgreSQL, Docker multi-stage builds, Eureka service discovery, Prometheus metrics.

---

## Architecture & Design Patterns

### Clean Architecture with Three-Layer Structure

The codebase enforces **strict separation of concerns** across three tiers:

1. **Entity Layer** (`src/main/java/com/kompu/api/entity/`)

   - Contains pure business logic, domain models, and gateway interfaces
   - **No Spring dependencies** - completely framework-agnostic
   - Models extend `AbstractEntity<T>` (e.g., `UserAccountModel`)
   - Gateway interfaces define contracts for data access (e.g., `UserGateway`, `UserTokenGateway`)
   - **Example:** `entity/user/model/UserAccountModel.java` contains business rules; `entity/user/gateway/UserGateway.java` declares CRUD operations

2. **Use Case Layer** (`src/main/java/com/kompu/api/usecase/`)

   - Orchestrates business logic by coordinating gateways
   - No HTTP, no database knowledge - purely algorithmic
   - **Example:** `GetUserUseCase` injects `UserGateway` and implements `findById()` with exception handling

3. **Infrastructure Layer** (`src/main/java/com/kompu/api/infrastructure/`)
   - **Gateway implementations** translate domain models ↔ database schemas
     - `UserDatabaseGateway` implements `UserGateway`, uses `UserRepository`
     - Converts `UserSchema` (JPA entity) to/from `UserAccountModel` (domain model)
   - **Controllers** are minimal HTTP adapters (located in `infrastructure/*/controller/`)
   - **Configurations** for security, database, web, and exception handling
   - **DTOs** for request/response serialization (`infrastructure/*/dto/`)

### Gateway Pattern (Repository Adapter)

Domain models (`*Model`) are never exposed to infrastructure. Data access is abstracted via gateway interfaces:

```
UserAccountModel (domain) ←→ UserGateway (interface) ←→ UserDatabaseGateway (impl) ←→ UserRepository (JPA)
```

---

## Key Implementation Patterns

### Entity/Schema Mapping

- `UserSchema` (JPA `@Entity`) includes audit fields via `@EntityListeners(AuditingEntityListener.class)`
- Schema classes have conversion methods: `toUserAccountModel()`, `new UserSchema(model)`
- **Audit fields:** `createdAt`, `updatedAt`, `createdBy`, `updatedBy` (auto-populated by Spring Data Auditing)

### Exception Handling

- **Custom exceptions** in `entity/*/exception/` inherit from `RuntimeException` and provide semantic error messages
  - E.g., `UserNotFoundException()` with message: "User not found in the system"
- **Global handler:** `GlobalRestControllerAdvice` (`@RestControllerAdvice`) catches all exceptions and returns standardized responses

### Security Architecture

- **Multi-layer filtering** in `AppSecurityConfigurer`:
  - `CorsSecurityFilter` → `SecurityMethodFilter` (JWT validation) → `RevokedJwtTokenFilter` (token revocation check)
- **Role-based access control** via `AppSecurityConfigurer.PUBLIC_ENDPOINTS`, `ADMIN_ENDPOINTS`, `USER_ENDPOINTS`
- **JWT tokens** generated by `MyAuthenticationHandler`, validated in `SecurityMethodFilter`
- **UserDetails** provided by `MyUserDetailService` (implements `UserDetailsService`)

### Database Constraints

- User roles enforce foreign key `FK_role_id` (users → user_roles many-to-one)
- Username has unique constraint across the `users` table
- Audit fields (`CreatedBy`, `CreatedDate`, `LastModifiedBy`, `LastModifiedDate`) auto-tracked by Spring JPA

---

## Building & Deployment

### Local Build

```bash
# Build with Maven
mvn clean package

# Run locally (default profile = 'prod', port 3333)
java -jar target/api-0.0.1-SNAPSHOT.jar

# Or with dev profile
java -jar target/api-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev
```

### Docker Multi-Stage Build

- **Stage 1** (`maven:3.9.6`): Compiles JAR, caches dependencies
- **Stage 2** (`eclipse-temurin:21-jre` builder): Extracts layered JAR (optimizes image size)
- **Stage 3** (final): Minimal JRE-only image, 2GB memory recommended
- **Entry:** `JarLauncher` with `JAVA_OPTS` support for GC tuning

### Environment Variables

- `SPRING_PROFILES_ACTIVE` (default: `prod`)
- `SERVER_PORT` (default: 3333)
- `SERVER_SSL_*` for HTTPS configuration
- `MANAGEMENT_SERVER_PORT` for actuator endpoints

---

## Testing Approach

- Test classes use Spring Security test utilities (`@WithMockUser`, `SecurityContextHolder`)
- Integration tests verify gateway implementations and repositories
- Use `@DataJpaTest` for repository tests; `@SpringBootTest` for full context

---

## Project Conventions

### Naming & Organization

- **Entity models:** `*Model` (e.g., `UserAccountModel`)
- **Database schemas:** `*Schema` (e.g., `UserSchema`)
- **Gateways:** `*Gateway` interface + `*DatabaseGateway` implementation
- **Use cases:** `*UseCase` class per operation
- **Controllers:** Located in `infrastructure/{domain}/controller/`
- **DTOs:** Located in `infrastructure/{domain}/dto/`

### Lombok Usage

All data classes use `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor` annotations.

### Database Migrations

- Located in `migration/` (e.g., `initial_07122025.sql`)
- Includes PostgreSQL schema setup with audit triggers and role-based functions
- Functions support multi-tenancy via session variables: `app.current_tenant()`, `app.current_user_id()`, `app.current_roles()`

---

## Common Tasks

### Adding a New Domain Entity

1. Create `entity/{domain}/model/{Entity}Model.java` (pure Java, no Spring)
2. Create `entity/{domain}/gateway/{Entity}Gateway.java` interface with CRUD methods
3. Create `entity/{domain}/exception/{Custom}Exception.java` for error handling
4. Create `infrastructure/config/db/schema/{Entity}Schema.java` with `@Entity` annotations
5. Create `infrastructure/config/db/repository/{Entity}Repository.java` extending `JpaRepository`
6. Implement `infrastructure/{domain}/gateway/{Entity}DatabaseGateway.java`
7. Add converter methods to schema: `to{Entity}Model()` and constructor `{Entity}Schema(model)`

### Adding a New Use Case

1. Create `usecase/{domain}/{Operation}UseCase.java` with gateway dependency injection
2. Implement business logic using gateway methods
3. Throw custom exceptions for error conditions

### Adding a New Controller Endpoint

1. Create `infrastructure/{domain}/controller/{Entity}Controller.java`
2. Inject `{Operation}UseCase` and call it
3. Map request DTOs to domain models
4. Return response DTOs (convert from domain models)
5. Endpoint access is controlled by `AppSecurityConfigurer` role-based path matchers

---

## External Integration Points

- **Eureka discovery:** Configured as client; service registers itself on startup
- **Prometheus metrics:** Exposed at `/actuator/metrics` and `/actuator/prometheus` (not exposed by default for security)
- **JWT token management:** JJWT 0.13.0 for signing/verifying tokens; token revocation tracked via `UserTokenSchema`
